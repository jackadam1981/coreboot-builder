--- a/src/drivers/net/r8168.c
+++ b/src/drivers/net/r8168.c
@@ -23,6 +23,7 @@
 
 #include "chip.h"
 
+#include <drivers/vpd/vpd.h>
 #define NIC_TIMEOUT		1000
 
 #define CMD_REG			0x37
@@ -97,6 +97,20 @@ static enum cb_err fetch_mac_vpd_key(u8 *macstrbuf, const char *vpd_key)
 	size_t search_length;
 	size_t offset;
 
+	/* Try using the proper VPD parsing function first */
+	const char *vpd_value;
+	int vpd_size;
+	printk(BIOS_DEBUG, "r8168: Searching for VPD key: '%s'\n", vpd_key);
+	vpd_value = vpd_find(vpd_key, &vpd_size, VPD_RO);
+	printk(BIOS_DEBUG, "r8168: vpd_find result: vpd_value=%p, vpd_size=%d\n", vpd_value, vpd_size);
+	if (vpd_value && vpd_size > 0) {
+		/* Copy the value to macstrbuf, ensuring null termination */
+		int copy_size = MIN(vpd_size, MACLEN - 1);
+		memcpy(macstrbuf, vpd_value, copy_size);
+		macstrbuf[copy_size] = '\0';
+		printk(BIOS_DEBUG, "r8168: Found MAC in VPD using vpd_find: %s\n", macstrbuf);
+		return CB_SUCCESS;
+	}
+	printk(BIOS_DEBUG, "r8168: vpd_find failed, trying legacy method\n");
+
 	if (fmap_locate_area_as_rdev("RO_VPD", &rdev)) {
 		printk(BIOS_ERR, "Couldn't find RO_VPD region.");
 		return CB_ERR;
@@ -120,6 +133,7 @@ static enum cb_err fetch_mac_vpd_dev_idx(u8 *macstrbuf, u8 device_index)
 	 * Map each NIC on the DUT to "ethernet_macN", where N is [0-9].
 	 * Translate index number from integer to ascii by adding '0' char.
 	 */
 	key[DEVICE_INDEX_BYTE] = device_index + '0';
+	printk(BIOS_DEBUG, "r8168: fetch_mac_vpd_dev_idx: device_index=%d, key='%s'\n", device_index, key);
 
 	return fetch_mac_vpd_key(macstrbuf, key);
 }
@@ -187,13 +201,21 @@ static void get_mac_address(u8 *macaddr, const u8 *strbuf)
 		return;
 	}
 
-	for (i = 0; i < 6; i++) {
-		macaddr[i] = 0;
-		macaddr[i] |= get_hex_digit(strbuf[offset]) << 4;
-		macaddr[i] |= get_hex_digit(strbuf[offset + 1]);
+	for (i = 0; i < 6; i++) {
+		u8 hex1, hex2;
+		hex1 = get_hex_digit(strbuf[offset]);
+		hex2 = get_hex_digit(strbuf[offset + 1]);
+
+		/* Check if both hex digits are valid */
+		if (hex1 > 0x0f || hex2 > 0x0f) {
+			printk(BIOS_ERR, "r8168: Invalid hex digit in MAC address at position %d\n", i);
+			return;
+		}
+
+		macaddr[i] = (hex1 << 4) | hex2;
 		offset += 3;
 	}
+	printk(BIOS_DEBUG, "r8168: Parsed MAC address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]);
 }
 
 static void program_mac_address(struct device *dev, u16 io_base)
@@ -264,6 +286,7 @@ static void program_mac_address(struct device *dev, u16 io_base)
 			inl(io_base + ERIDR);
 			outl(0x8000f0f4, io_base + ERIAR);
 			break;
+		case 9:
 		case 12:
 		case 13:
 		case 14:
@@ -271,6 +294,7 @@ static void program_mac_address(struct device *dev, u16 io_base)
 			/* RTL8111H revision 12-15 ERI programming */
 			printk(BIOS_DEBUG, "r8168: Programming ERI for RTL8111H revision %d\n", pci_read_config8(dev, PCI_REVISION_ID));
 			outl(maclo, io_base + ERIDR);
+			inl(io_base + ERIDR);
 			outl(0x8000f0e0, io_base + ERIAR);
 			inl(io_base + ERIAR);
 			outl(machi, io_base + ERIDR);
@@ -278,6 +302,7 @@ static void program_mac_address(struct device *dev, u16 io_base)
 			outl(0x800030e4, io_base + ERIAR);
 			printk(BIOS_DEBUG, "r8168: ERI programming completed for RTL8111H\n");
 			break;
+		case 9:
 		}
 		udelay(1000);
 	}

