name: 7-Kaisa MrChromebox (PXE ROM)

on:
  workflow_dispatch:
    inputs:
      release:
        description: "创建 Release 发布 / Create Release"
        required: false
        type: boolean
        default: true
      release_name:
        description: "Release 名称 / Release Name"
        required: false
        type: string
        default: "Coreboot Kaisa - 方案7 (RTL8111 PXE ROM)"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: 检出构建仓库 / Checkout Builder Repository
        uses: actions/checkout@v4

      - name: 拉取 Coreboot SDK 容器 / Pull Coreboot SDK
        run: docker pull coreboot/coreboot-sdk:latest

      - name: 克隆 MrChromebox Coreboot 源码 / Clone Coreboot Source
        run: |
          echo "📥 克隆 MrChromebox coreboot"
          git clone https://github.com/MrChromebox/coreboot.git coreboot
          cd coreboot
          git submodule update --init --checkout --recursive

      - name: 下载预编译 UEFI iPXE / Download Pre-built UEFI iPXE
        run: |
          echo "📥 下载预编译的 iPXE EFI 文件"
          cd coreboot
          
          # 下载完整版本 iPXE (包含常见驱动)
          echo "📦 下载完整版 iPXE (ipxe.efi)"
          curl -L -o ipxe.efi "https://boot.ipxe.org/ipxe.efi"
          
          # 下载精简版本 iPXE (依赖固件驱动)
          echo "📦 下载精简版 iPXE (snponly.efi)"
          curl -L -o snponly.efi "https://boot.ipxe.org/snponly.efi"
          
          # 下载专用 RTL8168 iPXE 驱动 (如果有的话)
          echo "📦 尝试下载专用 RTL8168 iPXE 驱动"
          curl -L -o rtl8168.efi "https://boot.ipxe.org/rtl8168.efi" || echo "⚠️ 专用驱动下载失败，将使用其他版本"
          
          # 如果下载失败，尝试使用本地编译的版本
          if [ ! -f "rtl8168.efi" ] && [ -f "/root/ipxe/src/bin-x86_64-efi/rtl8168.efi" ]; then
            echo "📦 使用本地编译的 RTL8168 驱动"
            cp /root/ipxe/src/bin-x86_64-efi/rtl8168.efi rtl8168.efi
          fi
          
          if [ -f ipxe.efi ]; then
            IPXE_SIZE=$(stat -c%s "ipxe.efi")
            IPXE_SIZE_KB=$((IPXE_SIZE / 1024))
            echo "✅ 完整版 iPXE 下载成功: ${IPXE_SIZE} 字节 (${IPXE_SIZE_KB} KB)"
          else
            echo "❌ 完整版 iPXE 下载失败"
            exit 1
          fi
          
          if [ -f snponly.efi ]; then
            SNPONLY_SIZE=$(stat -c%s "snponly.efi")
            SNPONLY_SIZE_KB=$((SNPONLY_SIZE / 1024))
            echo "✅ 精简版 iPXE 下载成功: ${SNPONLY_SIZE} 字节 (${SNPONLY_SIZE_KB} KB)"
          else
            echo "⚠️ 精简版 iPXE 下载失败，将只使用完整版"
          fi
          
          if [ -f rtl8168.efi ]; then
            RTL8168_SIZE=$(stat -c%s "rtl8168.efi")
            RTL8168_SIZE_KB=$((RTL8168_SIZE / 1024))
            echo "✅ RTL8168 专用驱动下载成功: ${RTL8168_SIZE} 字节 (${RTL8168_SIZE_KB} KB)"
          else
            echo "⚠️ RTL8168 专用驱动下载失败，将使用其他版本"
          fi

      - name: 配置 PXE ROM 支持 / Configure PXE ROM Support
        run: |
          echo "📝 添加 PXE ROM 支持配置"
          cd coreboot

          # 定义配置项数组
          PXE_CONFIGS=(
            "CONFIG_EDK2_NETWORK_PXE_SUPPORT=y"
            "CONFIG_EDK2_NETWORK_HTTP_BOOT_SUPPORT=y"
            "CONFIG_EDK2_NETWORK_ISCSI_SUPPORT=y"
            "CONFIG_EDK2_LOAD_OPTION_ROMS=y"
          )
          
          INTEL_CONFIGS=(

          )
          
          # 写入 PXE ROM 支持配置
            echo "" >> configs/cml/config.kaisa.uefi
            echo "# PXE ROM 支持配置" >> configs/cml/config.kaisa.uefi
          for config in "${PXE_CONFIGS[@]}"; do
            echo "$config" >> configs/cml/config.kaisa.uefi
          done
            echo "" >> configs/cml/config.kaisa.uefi
          
          # 写入 Intel 芯片组系统稳定配置
          if [ ${#INTEL_CONFIGS[@]} -gt 0 ]; then
            echo "# Intel 芯片组系统稳定配置（适合 Kaisa 主板）" >> configs/cml/config.kaisa.uefi
            for config in "${INTEL_CONFIGS[@]}"; do
              echo "$config" >> configs/cml/config.kaisa.uefi
            done
            echo "" >> configs/cml/config.kaisa.uefi
          fi
          
          # 保存配置到环境变量供后续使用
          echo "PXE_CONFIGS=${PXE_CONFIGS[*]}" >> $GITHUB_ENV
          echo "INTEL_CONFIGS=${INTEL_CONFIGS[*]}" >> $GITHUB_ENV
          
          # 为 Release body 生成格式化的配置列表
          PXE_CONFIG_LIST=""
          for config in "${PXE_CONFIGS[@]}"; do
            PXE_CONFIG_LIST="${PXE_CONFIG_LIST}- ${config}"$'\n'
          done
          echo "PXE_CONFIG_LIST<<EOF" >> $GITHUB_ENV
          echo "${PXE_CONFIG_LIST}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          INTEL_CONFIG_LIST=""
          if [ ${#INTEL_CONFIGS[@]} -gt 0 ]; then
            for config in "${INTEL_CONFIGS[@]}"; do
              INTEL_CONFIG_LIST="${INTEL_CONFIG_LIST}- ${config}"$'\n'
            done
            echo "INTEL_CONFIG_LIST<<EOF" >> $GITHUB_ENV
            echo "${INTEL_CONFIG_LIST}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "INTEL_CONFIG_LIST=" >> $GITHUB_ENV
          fi
          
          # 打印最终的配置文件内容
          echo "📋 最终配置文件内容:"
          echo "===================="
          cat configs/cml/config.kaisa.uefi
          echo "===================="

      - name: 📦 编译 MrChromebox Coreboot 固件 / Build Coreboot
        run: |
          echo "🔨 编译 MrChromebox coreboot（kaisa 主板）"
          
          # 使用 MrChromebox 标准编译流程（参考 build-coreboot.yml）
          # 确保输出目录权限正确
          mkdir -p roms
          chmod 755 roms
          
          # 使用 MrChromebox 标准编译流程
          docker run --rm --user root \
            -v ${{ github.workspace }}/coreboot:/home/coreboot/coreboot \
            -v ${{ github.workspace }}/roms:/home/coreboot/roms \
            -w /home/coreboot/coreboot \
            coreboot/coreboot-sdk:latest \
            bash -c "git config --global --add safe.directory /home/coreboot/coreboot && \
                     # 使用 MrChromebox 编译脚本（配置已在配置文件中）
                     echo '🔧 使用 MrChromebox build-uefi.sh 编译 kaisa...' && \
                     ./build-uefi.sh kaisa && \
                       chmod 644 /home/coreboot/roms/*.rom && \
                     echo '✅ MrChromebox 编译完成'"

      - name: 验证编译结果 / Verify Build Results
        run: |
          echo "📦 验证编译结果"

          # 检查 ROM 文件
          ROM_FILE=$(ls roms/coreboot_*.rom | head -1)
          if [ -z "$ROM_FILE" ]; then
            echo "❌ 未找到 ROM 文件"
            ls -la roms/
            exit 1
          fi
          
          echo "✅ 找到 ROM 文件: $(basename "$ROM_FILE")"
          ls -lh "$ROM_FILE"
          
          # 使用仓库内 tools/cbfstool 打印 ROM 结构（仅展示，不作为成败依据）
          echo "📦 使用本仓库 tools/cbfstool 打印 ROM 结构"
          CBFSTOOL="${{ github.workspace }}/tools/cbfstool"
          chmod +x "$CBFSTOOL" 2>/dev/null || true
          "$CBFSTOOL" "$ROM_FILE" print || echo "⚠️ cbfstool 打印失败（不影响构建产物上传）"
          
          # 使用 cbfstool 获取准确的空间信息
          echo "🔍 使用 cbfstool 分析 ROM 空间使用情况"
          
          # 获取 ROM 总大小
          ROM_SIZE=$(stat -c%s "$ROM_FILE")
          ROM_SIZE_MB=$((ROM_SIZE / 1024 / 1024))
          echo "📦 ROM 总大小: ${ROM_SIZE} 字节 (${ROM_SIZE_MB} MB)"
          
          # 使用 cbfstool 获取 COREBOOT 区域的容量和使用情况
          echo "📊 CBFS (COREBOOT) 空间分析:"
          CBFS_INFO=$("$CBFSTOOL" "$ROM_FILE" print 2>/dev/null || echo "")
          
          if [ -n "$CBFS_INFO" ]; then
            # 提取 COREBOOT 区域容量信息
            CBFS_CAPACITY=$(echo "$CBFS_INFO" | grep "CBFS.*capacity" | awk '{print $NF}' | head -1)
            if [ -n "$CBFS_CAPACITY" ]; then
              CBFS_CAPACITY_KB=$((CBFS_CAPACITY / 1024))
              echo "🏗️  CBFS 总容量: ${CBFS_CAPACITY} 字节 (${CBFS_CAPACITY_KB} KB)"
            fi
            
            # 计算已使用空间（所有非 empty/null 条目）
            USED_SIZE=$(echo "$CBFS_INFO" | grep -v -E "(empty|null|CBFS.*capacity)" | awk '{sum += $4} END {print sum+0}')
            if [ -n "$USED_SIZE" ] && [ "$USED_SIZE" -gt 0 ]; then
              USED_SIZE_KB=$((USED_SIZE / 1024))
              echo "📈 已使用空间: ${USED_SIZE} 字节 (${USED_SIZE_KB} KB)"
            fi
            
            # 计算可用空间（empty 和 null 条目）
            EMPTY_SIZE=$(echo "$CBFS_INFO" | grep -E "(empty|null)" | awk '{sum += $4} END {print sum+0}')
            if [ -n "$EMPTY_SIZE" ] && [ "$EMPTY_SIZE" -gt 0 ]; then
              EMPTY_SIZE_KB=$((EMPTY_SIZE / 1024))
              echo "💾 可用空间: ${EMPTY_SIZE} 字节 (${EMPTY_SIZE_KB} KB)"
              
              # 计算使用率
              if [ -n "$CBFS_CAPACITY" ] && [ "$CBFS_CAPACITY" -gt 0 ]; then
                USAGE_PERCENT=$(( (USED_SIZE * 100) / CBFS_CAPACITY ))
                echo "📊 空间使用率: ${USAGE_PERCENT}%"
              fi
            else
              echo "⚠️  未发现可用空间条目"
            fi
            
            # 显示最大的可用空间块
            LARGEST_EMPTY=$(echo "$CBFS_INFO" | grep -E "(empty|null)" | awk '{print $4}' | sort -nr | head -1)
            if [ -n "$LARGEST_EMPTY" ] && [ "$LARGEST_EMPTY" -gt 0 ]; then
              LARGEST_EMPTY_KB=$((LARGEST_EMPTY / 1024))
              echo "🎯 最大可用块: ${LARGEST_EMPTY} 字节 (${LARGEST_EMPTY_KB} KB)"
            fi
          else
            echo "❌ 无法获取 CBFS 信息"
          fi

      - name: 添加 iPXE EFI 到 ROM / Add iPXE EFI to ROM
        run: |
          echo "🔧 使用 cbfstool 添加 ipxe.efi 到 CBFS"
          ROM_FILE=$(ls roms/coreboot_*.rom | head -1)
          
          # 修复权限：GitHub Runner 上文件可能由 root 创建
          sudo chown $USER:$USER "$ROM_FILE" || true
          sudo chmod a+rw "$ROM_FILE" || true
          
          # 复制 cbfstool 到当前目录（假设仓库有 tools/cbfstool）
          cp ${{ github.workspace }}/tools/cbfstool cbfstool
          chmod +x cbfstool
          
          # 若存在旧的 Legacy PXE ROM 条目则删除以释放空间
          ./cbfstool "$ROM_FILE" remove -n pci10ec,8168.rom || true
          
          # 检查可用空间并选择合适的 iPXE 版本
          echo "🔍 检查空间并选择合适的 iPXE 版本"
          
          # 获取 iPXE 文件大小
          if [ -f "coreboot/ipxe.efi" ]; then
            IPXE_SIZE=$(stat -c%s "coreboot/ipxe.efi")
            IPXE_SIZE_KB=$((IPXE_SIZE / 1024))
            echo "📦 完整版 iPXE 大小: ${IPXE_SIZE} 字节 (${IPXE_SIZE_KB} KB)"
          fi
          
          if [ -f "coreboot/snponly.efi" ]; then
            SNPONLY_SIZE=$(stat -c%s "coreboot/snponly.efi")
            SNPONLY_SIZE_KB=$((SNPONLY_SIZE / 1024))
            echo "📦 精简版 iPXE 大小: ${SNPONLY_SIZE} 字节 (${SNPONLY_SIZE_KB} KB)"
          fi
          
          if [ -f "coreboot/rtl8168.efi" ]; then
            RTL8168_SIZE=$(stat -c%s "coreboot/rtl8168.efi")
            RTL8168_SIZE_KB=$((RTL8168_SIZE / 1024))
            echo "📦 RTL8168 专用驱动大小: ${RTL8168_SIZE} 字节 (${RTL8168_SIZE_KB} KB)"
          fi
          
          # 获取最大可用空间
          LARGEST_EMPTY=$("$CBFSTOOL" "$ROM_FILE" print 2>/dev/null | grep -E "(empty|null)" | awk '{print $4}' | sort -nr | head -1)
          if [ -n "$LARGEST_EMPTY" ] && [ "$LARGEST_EMPTY" -gt 0 ]; then
            LARGEST_EMPTY_KB=$((LARGEST_EMPTY / 1024))
            echo "💾 最大可用块: ${LARGEST_EMPTY} 字节 (${LARGEST_EMPTY_KB} KB)"
            
            # 选择合适的 iPXE 版本（优先级：RTL8168专用 > 完整版 > 精简版）
            if [ -f "coreboot/rtl8168.efi" ] && [ "$RTL8168_SIZE" -le "$LARGEST_EMPTY" ]; then
              echo "✅ 空间充足，使用 RTL8168 专用 iPXE 驱动"
              SELECTED_IPXE="coreboot/rtl8168.efi"
              USE_COMPRESSION=false
            elif [ -f "coreboot/ipxe.efi" ] && [ "$IPXE_SIZE" -le "$LARGEST_EMPTY" ]; then
              echo "✅ 空间充足，使用完整版 iPXE"
              SELECTED_IPXE="coreboot/ipxe.efi"
              USE_COMPRESSION=false
            elif [ -f "coreboot/snponly.efi" ] && [ "$SNPONLY_SIZE" -le "$LARGEST_EMPTY" ]; then
              echo "⚠️ 完整版太大，使用精简版 iPXE"
              SELECTED_IPXE="coreboot/snponly.efi"
              USE_COMPRESSION=false
            elif [ -f "coreboot/rtl8168.efi" ]; then
              echo "⚠️ 空间不足，使用 RTL8168 专用驱动 + LZMA 压缩"
              SELECTED_IPXE="coreboot/rtl8168.efi"
              USE_COMPRESSION=true
            elif [ -f "coreboot/ipxe.efi" ]; then
              echo "⚠️ 空间不足，使用完整版 iPXE + LZMA 压缩"
              SELECTED_IPXE="coreboot/ipxe.efi"
              USE_COMPRESSION=true
            elif [ -f "coreboot/snponly.efi" ]; then
              echo "⚠️ 空间不足，使用精简版 iPXE + LZMA 压缩"
              SELECTED_IPXE="coreboot/snponly.efi"
              USE_COMPRESSION=true
            else
              echo "❌ 没有可用的 iPXE 文件"
              exit 1
            fi
          else
            echo "⚠️ 无法确定可用空间，使用完整版 iPXE + 压缩"
            SELECTED_IPXE="coreboot/ipxe.efi"
            USE_COMPRESSION=true
          fi
          
          # 根据选择添加 iPXE
          echo "🚀 添加选定的 iPXE 版本: $(basename "$SELECTED_IPXE")"
          if [ "$USE_COMPRESSION" = true ]; then
            echo "🗜️ 使用 LZMA 压缩添加"
            set +e
            ./cbfstool "$ROM_FILE" add -f "$SELECTED_IPXE" -n efi/boot/bootx64.efi -t raw -c lzma
            ADD_RC=$?
            if [ $ADD_RC -ne 0 ]; then
              echo "⚠️ 作为 bootx64.efi 添加失败，尝试作为普通文件名添加"
              ./cbfstool "$ROM_FILE" add -f "$SELECTED_IPXE" -n "$(basename "$SELECTED_IPXE")" -t raw -c lzma
              ADD_RC=$?
            fi
            set -e
          else
            echo "📦 添加未压缩版本"
            set +e
            ./cbfstool "$ROM_FILE" add -f "$SELECTED_IPXE" -n efi/boot/bootx64.efi -t raw
            ADD_RC=$?
            if [ $ADD_RC -ne 0 ]; then
              echo "⚠️ 未压缩添加失败，回退到 LZMA 压缩"
              ./cbfstool "$ROM_FILE" add -f "$SELECTED_IPXE" -n efi/boot/bootx64.efi -t raw -c lzma
              ADD_RC=$?
            fi
            set -e
          fi
          
          if [ $ADD_RC -ne 0 ]; then
            echo "❌ 添加 ipxe.efi 失败"
            exit 1
          fi

          ./cbfstool "$ROM_FILE" print  # 验证
          echo "✅ iPXE EFI 已添加（尝试作为 bootx64.efi 或普通 ipxe.efi）"

      - name: 重新生成校验文件 / Regenerate Checksums
        run: |
          echo "🧮 重新生成 ROM 校验 (SHA1/SHA256)"
          ROM_FILE=$(ls roms/coreboot_*.rom | head -1)
          if [ -z "$ROM_FILE" ]; then
            echo "❌ 未找到 ROM 文件，无法生成校验"
            exit 1
          fi
          ROM_BASE=$(basename "$ROM_FILE")
          
          # 清理旧的校验文件，避免引用未修改前的校验
          rm -f "roms/${ROM_BASE}.sha1" "roms/${ROM_BASE}.sha256" || true
          
          # 在 roms/ 目录下生成标准 sha1sum/sha256sum 输出格式
          (cd roms && sha1sum "$ROM_BASE" > "${ROM_BASE}.sha1")
          (cd roms && sha256sum "$ROM_BASE" > "${ROM_BASE}.sha256")
          
          # 调试输出：打印计算得到的 SHA1 与文件内记录的 SHA1，用于校验比对
          COMPUTED_SHA1=$(cd roms && sha1sum "$ROM_BASE" | awk '{print $1}')
          FILE_SHA1=$(awk '{print $1}' "roms/${ROM_BASE}.sha1")
          echo "🔎 DEBUG SHA1 computed=${COMPUTED_SHA1} file=${FILE_SHA1}"
          if [ "$COMPUTED_SHA1" = "$FILE_SHA1" ]; then
            echo "✅ SHA1 一致"
          else
            echo "❗ SHA1 不一致（请检查生成流程）"
          fi
          
          echo "✅ 已生成: roms/${ROM_BASE}.sha1 与 roms/${ROM_BASE}.sha256"

      - name: 上传固件 / Upload Firmware
        uses: actions/upload-artifact@v4
        with:
          name: coreboot-kaisa-rtl8111-pxerom-${{ github.run_number }}
          path: |
            roms/*.rom
            roms/*.sha1
            roms/*.sha256
            integration_report.md

      - name: 创建 Release / Create Release
        if: ${{ (github.event_name == 'workflow_dispatch' && inputs.release) || (github.event_name != 'workflow_dispatch') }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: kaisa-rtl8111-pxerom-${{ github.run_number }}
          name: "${{ inputs.release_name || 'Coreboot Kaisa - 方案7 (RTL8111 PXE ROM)' }} #${{ github.run_number }}"
          body: |
            # 🎯 方案7：UEFI iPXE 集成 (ipxe.efi)
            
            - 下载预编译的 ipxe.efi (UEFI 兼容)
            - 添加到 CBFS 作为 ipxe.efi
            ${{ env.PXE_CONFIG_LIST }}
            
            注意：移除失败的 Legacy PXE ROM 支持，专注于 UEFI 版本
            ${{ env.INTEL_CONFIG_LIST != '' && format('同时追加 Intel 芯片组稳定性相关配置（适配 Kaisa 主板）：\n{0}', env.INTEL_CONFIG_LIST) || '' }}
            
            **构建时间**: ${{ github.event.repository.updated_at }}
          files: |
            roms/*.rom
            roms/*.sha1
            roms/*.sha256
            integration_report.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
