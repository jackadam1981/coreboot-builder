name: 7-Kaisa MrChromebox (EDK2 PXE + Updated UNDI Driver)

on:
  workflow_dispatch:
    inputs:
      release:
        description: "创建 Release 发布 / Create Release"
        required: false
        type: boolean
        default: true
      release_name:
        description: "Release 名称 / Release Name"
        required: false
        type: string
        default: "Coreboot Kaisa - 方案7 (EDK2 PXE + Updated UNDI Driver)"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: 检出构建仓库 / Checkout Builder Repository
        uses: actions/checkout@v4

      - name: 拉取 Coreboot SDK 容器 / Pull Coreboot SDK
        run: docker pull coreboot/coreboot-sdk:latest

      - name: 克隆 MrChromebox Coreboot 源码 / Clone Coreboot Source
        run: |
          echo "📥 克隆 MrChromebox coreboot"
          git clone https://github.com/MrChromebox/coreboot.git coreboot
          cd coreboot
          git submodule update --init --checkout --recursive

      - name: 准备更新的 RTL UNDI 驱动 / Prepare Updated RTL UNDI Driver
        run: |
          echo "🔧 准备更新的 RTL UNDI 驱动"
          cd coreboot
          
          # 检查是否有预下载的 RTL 驱动
          if [ -f "../RtkUndiDxe.efi" ]; then
            echo "✅ 找到预下载的 RTL UNDI 驱动"
            
            # 验证驱动文件
            echo "📊 驱动文件信息:"
            file "../RtkUndiDxe.efi"
            size=$(stat -c%s "../RtkUndiDxe.efi")
            echo "📏 文件大小: $size bytes"
            
            # 检查版本信息
            echo "📋 版本信息:"
            strings "../RtkUndiDxe.efi" | grep -i "version\|ver\|v[0-9]" | head -5
            
            # 检查 PXE/UNDI 功能
            echo "🌐 PXE/UNDI 功能:"
            strings "../RtkUndiDxe.efi" | grep -i "pxe\|undi" | head -5
            
            # 复制到构建目录
            echo "💾 复制 RTL 驱动到构建目录..."
            cp "../RtkUndiDxe.efi" "rtl_undi_driver_updated.efi"
            echo "✅ RTL UNDI 驱动准备完成"
            echo "📝 此驱动将在 EDK2 构建过程中被集成到固件中"
          else
            echo "⚠️ 未找到预下载的 RTL 驱动文件"
            echo "📝 将使用 MrChromebox EDK2 中的原始驱动"
          fi

      # 由于改用 EDK2 内置 PXE/HTTP 网络支持，不再准备或注入外部 iPXE 文件
      # 这里保留构建前的源码拉取与配置步骤

      - name: 验证 UNDI 驱动准备 / Verify UNDI Driver Preparation
        run: |
          echo "🔍 验证 UNDI 驱动准备结果"
          cd coreboot
          
          # 检查是否有准备的 RTL 驱动
          UPDATED_DRIVER="rtl_undi_driver_updated.efi"
          
          if [ -f "$UPDATED_DRIVER" ]; then
            echo "✅ 找到准备的 RTL 驱动: $UPDATED_DRIVER"
            
            # 显示驱动信息
            echo "📊 驱动文件信息:"
            file "$UPDATED_DRIVER"
            size=$(stat -c%s "$UPDATED_DRIVER")
            echo "📏 文件大小: $size bytes"
            
            # 检查版本信息
            echo "📋 版本信息:"
            strings "$UPDATED_DRIVER" | grep -i "version\|ver\|v[0-9]" | head -5
            
            # 检查 PXE/UNDI 功能
            echo "🌐 PXE/UNDI 功能:"
            strings "$UPDATED_DRIVER" | grep -i "pxe\|undi" | head -5
            
            echo "✅ RTL UNDI 驱动准备验证完成"
            echo "📝 此驱动将在 EDK2 构建过程中被集成到固件中"
          else
            echo "⚠️ 未找到准备的 RTL 驱动，将使用 MrChromebox EDK2 中的原始驱动"
            echo "📝 MrChromebox EDK2 仓库中的 RTL 驱动将被使用"
          fi

      - name: 配置 PXE ROM 支持 / Configure PXE ROM Support
        run: |
          echo "📝 添加 PXE ROM 支持配置"
          cd coreboot

          # 定义配置项数组
          PXE_CONFIGS=(
            "CONFIG_EDK2_NETWORK_PXE_SUPPORT=y"
            "CONFIG_EDK2_LOAD_OPTION_ROMS=y"
          )
          
          # 定义 EDK2 构建参数数组
          EDK2_BUILD_PARAMS=(
            "-D NETWORK_DRIVER_ENABLE=TRUE"
            "-D NETWORK_ENABLE=TRUE"
            "-D NETWORK_IP4_ENABLE=TRUE"
            "-D NETWORK_IP6_ENABLE=FALSE"
            "-D NETWORK_PXE_BOOT_ENABLE=TRUE"
            "-D NETWORK_HTTP_BOOT_ENABLE=FALSE"
            "-D NETWORK_SNP_ENABLE=TRUE"
            "-D NETWORK_RTEK_PCI=TRUE"
            "-D NETWORK_TLS_ENABLE=FALSE"
            "-D NETWORK_ISCSI_ENABLE=FALSE"
            "-D NETWORK_RTEK_USB=FALSE"
            "-D NETWORK_ASIX_USB3=FALSE"
            "-D NETWORK_ASIX_USB2=FALSE"
          )
          
          # 将 EDK2 构建参数分行写入配置文件
          echo "CONFIG_EDK2_CUSTOM_BUILD_PARAMS=\\" >> configs/cml/config.kaisa.uefi
          for param in "${EDK2_BUILD_PARAMS[@]}"; do
            echo "  $param \\" >> configs/cml/config.kaisa.uefi
          done
          # 移除最后一个反斜杠并添加引号
          sed -i '$ s/ \\$/"/' configs/cml/config.kaisa.uefi
          
          INTEL_CONFIGS=(
            "CONFIG_SOC_INTEL_COMMON_BLOCK_POWER_LIMIT=y"
            "CONFIG_SOC_INTEL_COMMON_BLOCK_THERMAL=y"
            "CONFIG_SOUTHBRIDGE_INTEL_COMMON_WATCHDOG=y"
            "CONFIG_EC_GOOGLE_CHROMEEC_AUTO_FAN_CTRL=y"
          )
          
          # 写入 PXE ROM 支持配置到文件尾部
          echo "" >> configs/cml/config.kaisa.uefi
          echo "# PXE ROM 支持配置" >> configs/cml/config.kaisa.uefi
          for config in "${PXE_CONFIGS[@]}"; do
            echo "$config" >> configs/cml/config.kaisa.uefi
          done
          echo "" >> configs/cml/config.kaisa.uefi
          
          # 写入 Intel 芯片组系统稳定配置
          if [ ${#INTEL_CONFIGS[@]} -gt 0 ]; then
            echo "# Intel 芯片组系统稳定配置（适合 Kaisa 主板）" >> configs/cml/config.kaisa.uefi
            for config in "${INTEL_CONFIGS[@]}"; do
              echo "$config" >> configs/cml/config.kaisa.uefi
            done
            echo "" >> configs/cml/config.kaisa.uefi
          fi
          
          # 保存配置到环境变量供后续使用
          echo "PXE_CONFIGS=${PXE_CONFIGS[*]}" >> $GITHUB_ENV
          echo "INTEL_CONFIGS=${INTEL_CONFIGS[*]}" >> $GITHUB_ENV
          
          # 为 Release body 生成格式化的配置列表
          PXE_CONFIG_LIST=""
          for config in "${PXE_CONFIGS[@]}"; do
            PXE_CONFIG_LIST="${PXE_CONFIG_LIST}- ${config}"$'\n'
          done
          echo "PXE_CONFIG_LIST<<EOF" >> $GITHUB_ENV
          echo "${PXE_CONFIG_LIST}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          INTEL_CONFIG_LIST=""
          if [ ${#INTEL_CONFIGS[@]} -gt 0 ]; then
            for config in "${INTEL_CONFIGS[@]}"; do
              INTEL_CONFIG_LIST="${INTEL_CONFIG_LIST}- ${config}"$'\n'
            done
            echo "INTEL_CONFIG_LIST<<EOF" >> $GITHUB_ENV
            echo "${INTEL_CONFIG_LIST}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "INTEL_CONFIG_LIST=" >> $GITHUB_ENV
          fi
          
          # 打印最终的配置文件内容
          echo "📋 最终配置文件内容:"
          echo "===================="
          cat configs/cml/config.kaisa.uefi
          echo "===================="

      - name: 🔨 首次编译（下载 EDK2）/ First Build (Download EDK2)
        run: |
          echo "🔨 首次编译 MrChromebox coreboot（下载 EDK2）"
          
          # 确保输出目录权限正确
          mkdir -p roms
          chmod 755 roms
          
          # 首次编译，触发 EDK2 下载
          docker run --rm --user root \
            -v ${{ github.workspace }}/coreboot:/home/coreboot/coreboot \
            -v ${{ github.workspace }}/roms:/home/coreboot/roms \
            -w /home/coreboot/coreboot \
            coreboot/coreboot-sdk:latest \
            bash -c "git config --global --add safe.directory /home/coreboot/coreboot && \
                     # 准备配置文件
                     echo '🔧 准备配置文件...' && \
                     cfg_file=\$(find ./configs -name 'config.kaisa.uefi') && \
                     cp \"\$cfg_file\" .config && \
                     echo 'CONFIG_LOCALVERSION=\"\$(git describe --tags --dirty)\"' >> .config && \
                     make clean && \
                     make olddefconfig && \
                     # 开始首次构建（这会触发 EDK2 下载）
                     echo '🔧 开始首次构建 coreboot（会自动下载 EDK2）...' && \
                     make -j\$(nproc) || true && \
                     echo '✅ 首次构建完成（EDK2 已下载）'"

      - name: 🔍 检查首次编译后的驱动 / Check Driver After First Build
        run: |
          echo "🔍 检查首次编译后的 RTL 驱动状态"
          
          # 检查首次编译后的驱动文件
          docker run --rm --user root \
            -v ${{ github.workspace }}/coreboot:/home/coreboot/coreboot \
            -v ${{ github.workspace }}/roms:/home/coreboot/roms \
            -w /home/coreboot/coreboot \
            coreboot/coreboot-sdk:latest \
            bash -c "echo '🔍 检查 EDK2 是否已下载...' && \
                     if [ -d 'payloads/external/edk2/workspace' ]; then \
                       echo '✅ EDK2 已下载'; \
                       EDK2_DRIVER_PATH=\$(find payloads/external/edk2/workspace -name 'RtkUndiDxe.efi' 2>/dev/null | head -1); \
                       if [ -n \"\$EDK2_DRIVER_PATH\" ]; then \
                         echo \"📦 找到 EDK2 RTL 驱动: \$EDK2_DRIVER_PATH\"; \
                         echo '📊 原始驱动文件信息:'; \
                         file \"\$EDK2_DRIVER_PATH\"; \
                         size=\$(stat -c%s \"\$EDK2_DRIVER_PATH\"); \
                         echo \"📏 文件大小: \$size bytes\"; \
                         echo '📋 原始驱动版本信息:'; \
                         strings \"\$EDK2_DRIVER_PATH\" | grep -i 'version\|ver\|v[0-9]' | head -3; \
                       else \
                         echo '⚠️ 未找到 EDK2 RTL 驱动文件'; \
                       fi; \
                     else \
                       echo '❌ EDK2 未下载'; \
                     fi"

      - name: 🔄 替换 RTL 驱动 / Replace RTL Driver
        run: |
          echo "🔄 替换 RTL UNDI 驱动"
          
          # 在构建环境中替换 RTL 驱动
          docker run --rm --user root \
            -v ${{ github.workspace }}/coreboot:/home/coreboot/coreboot \
            -v ${{ github.workspace }}/roms:/home/coreboot/roms \
            -w /home/coreboot/coreboot \
            coreboot/coreboot-sdk:latest \
            bash -c "echo '🔍 检查 EDK2 是否已下载...' && \
                     if [ -d 'payloads/external/edk2/workspace' ]; then \
                       echo '✅ EDK2 已下载，准备替换 RTL 驱动...'; \
                       EDK2_DRIVER_PATH=\$(find payloads/external/edk2/workspace -name 'RtkUndiDxe.efi' 2>/dev/null | head -1); \
                       if [ -n \"\$EDK2_DRIVER_PATH\" ]; then \
                         echo \"📦 找到 EDK2 RTL 驱动: \$EDK2_DRIVER_PATH\"; \
                         if [ -f '/home/coreboot/coreboot/rtl_undi_driver_updated.efi' ]; then \
                           echo \"🔄 替换为新版本驱动...\"; \
                           cp /home/coreboot/coreboot/rtl_undi_driver_updated.efi \"\$EDK2_DRIVER_PATH\"; \
                           echo '✅ RTL 驱动已替换'; \
                           # 清理 EDK2 构建缓存，强制重新构建
                           rm -rf payloads/external/edk2/workspace/Build; \
                           echo '🧹 EDK2 构建缓存已清理'; \
                           # 验证替换结果
                           echo '🔍 验证驱动替换结果:'; \
                           file \"\$EDK2_DRIVER_PATH\"; \
                           new_size=\$(stat -c%s \"\$EDK2_DRIVER_PATH\"); \
                           echo \"📏 新文件大小: \$new_size bytes\"; \
                           echo '📋 新驱动版本信息:'; \
                           strings \"\$EDK2_DRIVER_PATH\" | grep -i 'version\|ver\|v[0-9]' | head -3; \
                         else \
                           echo '⚠️ 未找到新驱动文件，使用原有驱动'; \
                         fi; \
                       else \
                         echo '⚠️ 未找到 EDK2 RTL 驱动文件'; \
                       fi; \
                     else \
                       echo '❌ EDK2 未下载，无法替换驱动'; \
                     fi"

      - name: 🔨 重新编译（使用新驱动）/ Rebuild with New Driver
        run: |
          echo "🔨 重新编译 coreboot（使用新的 RTL 驱动）"
          
          # 重新编译，使用替换后的驱动
          docker run --rm --user root \
            -v ${{ github.workspace }}/coreboot:/home/coreboot/coreboot \
            -v ${{ github.workspace }}/roms:/home/coreboot/roms \
            -w /home/coreboot/coreboot \
            coreboot/coreboot-sdk:latest \
            bash -c "echo '🔧 重新构建 coreboot（使用新的 RTL 驱动）...' && \
                     make -j\$(nproc) && \
                     # 复制 ROM 文件到输出目录
                     if [ -f 'build/coreboot.rom' ]; then \
                       cp build/coreboot.rom /home/coreboot/roms/; \
                       chmod 644 /home/coreboot/roms/coreboot.rom; \
                       echo '✅ ROM 文件已复制到输出目录'; \
                     else \
                       echo '⚠️ 未找到生成的 ROM 文件'; \
                     fi && \
                     echo '✅ MrChromebox 编译完成'"

      - name: 🔍 检查重新编译后的驱动 / Check Driver After Rebuild
        run: |
          echo "🔍 检查重新编译后的 RTL 驱动状态"
          
          # 检查重新编译后的驱动文件
          docker run --rm --user root \
            -v ${{ github.workspace }}/coreboot:/home/coreboot/coreboot \
            -v ${{ github.workspace }}/roms:/home/coreboot/roms \
            -w /home/coreboot/coreboot \
            coreboot/coreboot-sdk:latest \
            bash -c "echo '🔍 检查重新编译后的驱动状态...' && \
                     if [ -d 'payloads/external/edk2/workspace' ]; then \
                       echo '✅ EDK2 工作区存在'; \
                       EDK2_DRIVER_PATH=\$(find payloads/external/edk2/workspace -name 'RtkUndiDxe.efi' 2>/dev/null | head -1); \
                       if [ -n \"\$EDK2_DRIVER_PATH\" ]; then \
                         echo \"📦 找到 EDK2 RTL 驱动: \$EDK2_DRIVER_PATH\"; \
                         echo '📊 最终驱动文件信息:'; \
                         file \"\$EDK2_DRIVER_PATH\"; \
                         final_size=\$(stat -c%s \"\$EDK2_DRIVER_PATH\"); \
                         echo \"📏 文件大小: \$final_size bytes\"; \
                         echo '📋 最终驱动版本信息:'; \
                         strings \"\$EDK2_DRIVER_PATH\" | grep -i 'version\|ver\|v[0-9]' | head -3; \
                         echo '🌐 PXE/UNDI 功能检查:'; \
                         strings \"\$EDK2_DRIVER_PATH\" | grep -i 'pxe\|undi' | head -3; \
                         echo '✅ 驱动状态检查完成'; \
                       else \
                         echo '⚠️ 未找到 EDK2 RTL 驱动文件'; \
                       fi; \
                     else \
                       echo '❌ EDK2 工作区不存在'; \
                     fi"

      - name: 验证编译结果 / Verify Build Results
        run: |
          echo "📦 验证编译结果"

          # 检查 ROM 文件（可能在 roms/ 或 build/ 目录）
          ROM_FILE=""
          if [ -f "roms/coreboot.rom" ]; then
            ROM_FILE="roms/coreboot.rom"
          elif [ -f "coreboot/build/coreboot.rom" ]; then
            ROM_FILE="coreboot/build/coreboot.rom"
          else
            echo "❌ 未找到 ROM 文件"
            echo "检查 roms/ 目录:"
            ls -la roms/ 2>/dev/null || echo "roms/ 目录不存在"
            echo "检查 coreboot/build/ 目录:"
            ls -la coreboot/build/ 2>/dev/null || echo "coreboot/build/ 目录不存在"
            exit 1
          fi
          
          echo "✅ 找到 ROM 文件: $(basename "$ROM_FILE")"
          ls -lh "$ROM_FILE"
          
          # 使用仓库内 tools/cbfstool 打印 ROM 结构（仅展示，不作为成败依据）
          echo "📦 使用本仓库 tools/cbfstool 打印 ROM 结构"
          CBFSTOOL="${{ github.workspace }}/tools/cbfstool"
          chmod +x "$CBFSTOOL" 2>/dev/null || true
          "$CBFSTOOL" "$ROM_FILE" print || echo "⚠️ cbfstool 打印失败（不影响构建产物上传）"
          
          # 使用 cbfstool 获取准确的空间信息
          echo "🔍 使用 cbfstool 分析 ROM 空间使用情况"
          
          # 获取 ROM 总大小
          ROM_SIZE=$(stat -c%s "$ROM_FILE")
          ROM_SIZE_MB=$((ROM_SIZE / 1024 / 1024))
          echo "📦 ROM 总大小: ${ROM_SIZE} 字节 (${ROM_SIZE_MB} MB)"
          
          # 使用 cbfstool 获取 COREBOOT 区域的容量和使用情况
          echo "📊 CBFS (COREBOOT) 空间分析:"
          CBFS_INFO=$("$CBFSTOOL" "$ROM_FILE" print 2>/dev/null || echo "")
          
          if [ -n "$CBFS_INFO" ]; then
            # 提取 COREBOOT 区域容量信息
            CBFS_CAPACITY=$(echo "$CBFS_INFO" | grep "CBFS.*capacity" | awk '{print $NF}' | head -1)
            if [ -n "$CBFS_CAPACITY" ]; then
              CBFS_CAPACITY_KB=$((CBFS_CAPACITY / 1024))
              echo "🏗️  CBFS 总容量: ${CBFS_CAPACITY} 字节 (${CBFS_CAPACITY_KB} KB)"
            fi
            
            # 计算已使用空间（所有非 empty/null 条目）
            USED_SIZE=$(echo "$CBFS_INFO" | grep -v -E "(empty|null|CBFS.*capacity)" | awk '{sum += $4} END {print sum+0}')
            if [ -n "$USED_SIZE" ] && [ "$USED_SIZE" -gt 0 ]; then
              USED_SIZE_KB=$((USED_SIZE / 1024))
              echo "📈 已使用空间: ${USED_SIZE} 字节 (${USED_SIZE_KB} KB)"
            fi
            
            # 计算可用空间（empty 和 null 条目）
            EMPTY_SIZE=$(echo "$CBFS_INFO" | grep -E "(empty|null)" | awk '{sum += $4} END {print sum+0}')
            if [ -n "$EMPTY_SIZE" ] && [ "$EMPTY_SIZE" -gt 0 ]; then
              EMPTY_SIZE_KB=$((EMPTY_SIZE / 1024))
              echo "💾 可用空间: ${EMPTY_SIZE} 字节 (${EMPTY_SIZE_KB} KB)"
              
              # 计算使用率
              if [ -n "$CBFS_CAPACITY" ] && [ "$CBFS_CAPACITY" -gt 0 ]; then
                USAGE_PERCENT=$(( (USED_SIZE * 100) / CBFS_CAPACITY ))
                echo "📊 空间使用率: ${USAGE_PERCENT}%"
              fi
            else
              echo "⚠️  未发现可用空间条目"
            fi
            
            # 显示最大的可用空间块
            LARGEST_EMPTY=$(echo "$CBFS_INFO" | grep -E "(empty|null)" | awk '{print $4}' | sort -nr | head -1)
            if [ -n "$LARGEST_EMPTY" ] && [ "$LARGEST_EMPTY" -gt 0 ]; then
              LARGEST_EMPTY_KB=$((LARGEST_EMPTY / 1024))
              echo "🎯 最大可用块: ${LARGEST_EMPTY} 字节 (${LARGEST_EMPTY_KB} KB)"
            fi
          else
            echo "❌ 无法获取 CBFS 信息"
          fi

      # 删除外部 iPXE 注入步骤：改为完全依赖 EDK2 内置网络栈

      - name: 重新生成校验文件 / Regenerate Checksums
        run: |
          echo "🧮 重新生成 ROM 校验 (SHA1/SHA256)"
          ROM_FILE=$(ls roms/coreboot_*.rom | head -1)
          if [ -z "$ROM_FILE" ]; then
            echo "❌ 未找到 ROM 文件，无法生成校验"
            exit 1
          fi
          ROM_BASE=$(basename "$ROM_FILE")
          
          # 清理旧的校验文件，避免引用未修改前的校验
          rm -f "roms/${ROM_BASE}.sha1" "roms/${ROM_BASE}.sha256" || true
          
          # 在 roms/ 目录下生成标准 sha1sum/sha256sum 输出格式
          (cd roms && sha1sum "$ROM_BASE" > "${ROM_BASE}.sha1")
          (cd roms && sha256sum "$ROM_BASE" > "${ROM_BASE}.sha256")
          
          # 调试输出：打印计算得到的 SHA1 与文件内记录的 SHA1，用于校验比对
          COMPUTED_SHA1=$(cd roms && sha1sum "$ROM_BASE" | awk '{print $1}')
          FILE_SHA1=$(awk '{print $1}' "roms/${ROM_BASE}.sha1")
          echo "🔎 DEBUG SHA1 computed=${COMPUTED_SHA1} file=${FILE_SHA1}"
          if [ "$COMPUTED_SHA1" = "$FILE_SHA1" ]; then
            echo "✅ SHA1 一致"
          else
            echo "❗ SHA1 不一致（请检查生成流程）"
          fi
          
          echo "✅ 已生成: roms/${ROM_BASE}.sha1 与 roms/${ROM_BASE}.sha256"

      - name: 上传固件 / Upload Firmware
        uses: actions/upload-artifact@v4
        with:
          name: coreboot-kaisa-edk2-pxe-${{ github.run_number }}
          path: |
            roms/*.rom
            roms/*.sha1
            roms/*.sha256
            integration_report.md

      - name: 创建 Release / Create Release
        if: ${{ (github.event_name == 'workflow_dispatch' && inputs.release) || (github.event_name != 'workflow_dispatch') }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: kaisa-edk2-pxe-${{ github.run_number }}
          name: "${{ inputs.release_name || 'Coreboot Kaisa - 方案7 (EDK2 PXE)' }} #${{ github.run_number }}"
          body: |
           # 🎯 方案7：MrChromebox EDK2 内置 PXE 网络启动 + 更新 UNDI 驱动
           
           ## 🔧 启用的固件网络功能
           - **网络驱动启用**：NETWORK_DRIVER_ENABLE=TRUE
           - **网络功能启用**：NETWORK_ENABLE=TRUE
           - **IPv4 网络支持**：NETWORK_IP4_ENABLE=TRUE
           - **PXE 启动支持**：NETWORK_PXE_BOOT_ENABLE=TRUE
           - **SNP 协议支持**：NETWORK_SNP_ENABLE=TRUE（Simple Network Protocol）
           - **RTL8168 PCI 网卡**：NETWORK_RTEK_PCI=TRUE（支持 RTL8111/8168/8169）
           - **HTTP Boot 禁用**：NETWORK_HTTP_BOOT_ENABLE=FALSE（节省空间）
           - **IPv6 禁用**：NETWORK_IP6_ENABLE=FALSE（节省空间）
           - **Option ROM 加载**：支持 PCIe 设备 Option ROM
           
           ## 🔄 UNDI 驱动更新
           - **尝试下载最新 RTL UNDI 驱动**：Realtek UEFI UNDI 驱动 2.068 版本
           - **支持更多 RTL 网卡型号**：RTL8168B/E/H, RTL8111B/C/D/E/F/G/H 等
           - **改进 MAC 地址读取**：解决 MAC 地址全零问题
           - **增强硬件兼容性**：支持更多 RTL 网卡变种
           
           ${{ env.PXE_CONFIG_LIST }}
           
           ## 🚀 使用方法
           - 刷入固件后，在 UEFI 启动菜单中选择 Network/PXE 相关选项即可
           
           ## 🔧 调试工具
           - **efi-debug-script-v2.nsh**：增强版 EFI Shell 调试脚本，专门优化网络启动诊断
           - **network-boot-diagnostics.nsh**：专业网络启动诊断脚本，专注于 PXE/HTTP Boot 问题排查
           - **uefi-boot-setup.nsh**：iPXE 启动菜单设置脚本（备选方案）
           
           ${{ env.INTEL_CONFIG_LIST != '' && format('同时追加 Intel 芯片组稳定性相关配置（适配 Kaisa 主板）：\n{0}', env.INTEL_CONFIG_LIST) || '' }}
            
            **构建时间**: ${{ github.event.repository.updated_at }}
          files: |
            roms/*.rom
            roms/*.sha1
            roms/*.sha256
            integration_report.md
            efi-debug-script-v2.nsh
            network-boot-diagnostics.nsh
            uefi-boot-setup.nsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
