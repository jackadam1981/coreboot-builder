name: 8-Kaisa Official EDK2 (Network Support)

on:
  workflow_dispatch:
    inputs:
      release:
        description: "创建 Release 发布 / Create Release"
        required: false
        type: boolean
        default: true
      release_name:
        description: "Release 名称 / Release Name"
        required: false
        type: string
        default: "Coreboot Kaisa - 方案8 (Official EDK2 Network)"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: 检出代码 / Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: 设置环境 / Setup Environment
      run: |
        echo "🔧 设置构建环境"
        sudo apt-get update
        sudo apt-get install -y build-essential git curl wget
        sudo apt-get install -y gcc-multilib g++-multilib
        sudo apt-get install -y python3 python3-pip
        sudo apt-get install -y device-tree-compiler
        sudo apt-get install -y libssl-dev libncurses5-dev
        sudo apt-get install -y bison flex
        sudo apt-get install -y zlib1g-dev
        sudo apt-get install -y libfdt-dev

    - name: 克隆 MrChromebox coreboot / Clone MrChromebox coreboot
      run: |
        echo "📥 克隆 MrChromebox coreboot"
        git clone https://github.com/mrchromebox/coreboot.git MrChromebox
        cd MrChromebox
        git submodule update --init --recursive

    - name: 配置原版 EDK2 支持 / Configure Official EDK2 Support
      run: |
        echo "📝 配置原版 EDK2 网络支持"
        cd MrChromebox

        # 定义配置项数组
        EDK2_CONFIGS=(
          "CONFIG_EDK2_REPO_OFFICIAL=y"
          "CONFIG_EDK2_REPOSITORY=\"https://github.com/tianocore/edk2\""
          "CONFIG_EDK2_TAG_OR_REV=\"origin/master\""
          "CONFIG_EDK2_RELEASE=y"
          "CONFIG_EDK2_HAVE_EFI_SHELL=y"
          "CONFIG_EDK2_CUSTOM_BUILD_PARAMS=\"-D NETWORK_ENABLE=TRUE -D NETWORK_IP6_ENABLE=FALSE\""
        )
        
        INTEL_CONFIGS=(
          "CONFIG_SOC_INTEL_COMMON_BLOCK_POWER_LIMIT=y"
          "CONFIG_SOC_INTEL_COMMON_BLOCK_THERMAL=y"
          "CONFIG_SOUTHBRIDGE_INTEL_COMMON_WATCHDOG=y"
          "CONFIG_EC_GOOGLE_CHROMEEC_AUTO_FAN_CTRL=y"
        )

        # 写入配置文件
        echo "写入 EDK2 配置..."
        for config in "${EDK2_CONFIGS[@]}"; do
          echo "$config" >> configs/cml/config.kaisa.uefi
        done
        
        # 写入 Intel 配置（如果数组不为空）
        if [ ${#INTEL_CONFIGS[@]} -gt 0 ]; then
          echo "" >> configs/cml/config.kaisa.uefi
          echo "# Intel 芯片组稳定性配置" >> configs/cml/config.kaisa.uefi
          for config in "${INTEL_CONFIGS[@]}"; do
            echo "$config" >> configs/cml/config.kaisa.uefi
          done
        fi

        # 保存格式化的配置列表到环境变量
        EDK2_CONFIG_LIST=""
        for config in "${EDK2_CONFIGS[@]}"; do
          EDK2_CONFIG_LIST="${EDK2_CONFIG_LIST}- ${config}"$'\n'
        done
        echo "EDK2_CONFIG_LIST<<EOF" >> $GITHUB_ENV
        echo "${EDK2_CONFIG_LIST}" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        
        INTEL_CONFIG_LIST=""
        for config in "${INTEL_CONFIGS[@]}"; do
          INTEL_CONFIG_LIST="${INTEL_CONFIG_LIST}- ${config}"$'\n'
        done
        echo "INTEL_CONFIG_LIST<<EOF" >> $GITHUB_ENV
        echo "${INTEL_CONFIG_LIST}" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

        # 打印最终的配置文件内容
        echo "📋 最终配置文件内容:"
        echo "===================="
        cat configs/cml/config.kaisa.uefi
        echo "===================="

    - name: 编译 MrChromebox coreboot / Build MrChromebox coreboot
      run: |
        echo "🔨 编译 MrChromebox coreboot（kaisa 主板，原版 EDK2）"
        cd MrChromebox
        ./build-uefi.sh kaisa

    - name: 验证编译结果 / Verify Build Results
      run: |
        echo "📦 验证编译结果"
        cd MrChromebox
        
        # 查找 ROM 文件
        ROM_FILE=$(ls roms/coreboot_*.rom | head -1)
        if [ -z "$ROM_FILE" ]; then
          echo "❌ 未找到 ROM 文件"
          exit 1
        fi
        
        echo "✅ 找到 ROM 文件: $(basename "$ROM_FILE")"
        ls -lh "$ROM_FILE"
        
        # 使用 cbfstool 分析 ROM 内容
        echo "📦 使用本仓库 tools/cbfstool 打印 ROM 结构"
        cp ../tools/cbfstool cbfstool
        chmod +x cbfstool
        ./cbfstool "$ROM_FILE" print
        
        # 使用 cbfstool 获取准确的空间信息
        echo "🔍 使用 cbfstool 分析 ROM 空间使用情况"
        
        # 获取 ROM 总大小
        ROM_SIZE=$(stat -c%s "$ROM_FILE")
        ROM_SIZE_MB=$((ROM_SIZE / 1024 / 1024))
        echo "📦 ROM 总大小: ${ROM_SIZE} 字节 (${ROM_SIZE_MB} MB)"
        
        # 使用 cbfstool 获取 COREBOOT 区域的容量和使用情况
        echo "📊 CBFS (COREBOOT) 空间分析:"
        CBFS_INFO=$("./cbfstool" "$ROM_FILE" print 2>/dev/null || echo "")
        
        if [ -n "$CBFS_INFO" ]; then
          # 提取 COREBOOT 区域容量信息
          CBFS_CAPACITY=$(echo "$CBFS_INFO" | grep "CBFS.*capacity" | awk '{print $NF}' | head -1)
          if [ -n "$CBFS_CAPACITY" ]; then
            CBFS_CAPACITY_KB=$((CBFS_CAPACITY / 1024))
            echo "🏗️  CBFS 总容量: ${CBFS_CAPACITY} 字节 (${CBFS_CAPACITY_KB} KB)"
          fi
          
          # 计算已使用空间（所有非 empty/null 条目）
          USED_SIZE=$(echo "$CBFS_INFO" | grep -v -E "(empty|null|CBFS.*capacity)" | awk '{sum += $4} END {print sum+0}')
          if [ -n "$USED_SIZE" ] && [ "$USED_SIZE" -gt 0 ]; then
            USED_SIZE_KB=$((USED_SIZE / 1024))
            echo "📈 已使用空间: ${USED_SIZE} 字节 (${USED_SIZE_KB} KB)"
          fi
          
          # 计算可用空间（empty 和 null 条目）
          EMPTY_SIZE=$(echo "$CBFS_INFO" | grep -E "(empty|null)" | awk '{sum += $4} END {print sum+0}')
          if [ -n "$EMPTY_SIZE" ] && [ "$EMPTY_SIZE" -gt 0 ]; then
            EMPTY_SIZE_KB=$((EMPTY_SIZE / 1024))
            echo "💾 可用空间: ${EMPTY_SIZE} 字节 (${EMPTY_SIZE_KB} KB)"
            
            # 计算使用率
            if [ -n "$CBFS_CAPACITY" ] && [ "$CBFS_CAPACITY" -gt 0 ]; then
              USAGE_PERCENT=$(( (USED_SIZE * 100) / CBFS_CAPACITY ))
              echo "📊 空间使用率: ${USAGE_PERCENT}%"
            fi
          else
            echo "⚠️  未发现可用空间条目"
          fi
          
          # 显示最大的可用空间块
          LARGEST_EMPTY=$(echo "$CBFS_INFO" | grep -E "(empty|null)" | awk '{print $4}' | sort -nr | head -1)
          if [ -n "$LARGEST_EMPTY" ] && [ "$LARGEST_EMPTY" -gt 0 ]; then
            LARGEST_EMPTY_KB=$((LARGEST_EMPTY / 1024))
            echo "🎯 最大可用块: ${LARGEST_EMPTY} 字节 (${LARGEST_EMPTY_KB} KB)"
          fi
        else
          echo "❌ 无法获取 CBFS 信息"
        fi

    - name: 检查网络驱动 / Check Network Drivers
      run: |
        echo "🔍 检查构建产物中的网络驱动"
        cd MrChromebox
        
        # 查找网络相关的 EFI 文件
        echo "搜索网络相关的 EFI 文件..."
        find . -name "*.efi" | grep -i network || echo "未找到网络相关 EFI 文件"
        find . -name "*.efi" | grep -i pci || echo "未找到 PCI 相关 EFI 文件"
        find . -name "*.efi" | grep -i pxe || echo "未找到 PXE 相关 EFI 文件"
        
        # 检查构建日志中的网络相关信息
        echo ""
        echo "检查构建日志中的网络信息..."
        if [ -f "payloads/external/edk2/workspace/Build/UefiPayloadPkgX64/RELEASE_GCC5/UEFIPAYLOAD.txt" ]; then
          echo "EDK2 构建日志中的网络相关信息："
          grep -i "network\|pci\|pxe" payloads/external/edk2/workspace/Build/UefiPayloadPkgX64/RELEASE_GCC5/UEFIPAYLOAD.txt | head -10 || echo "未找到网络相关信息"
        else
          echo "未找到 EDK2 构建日志"
        fi

    - name: 复制 ROM 文件 / Copy ROM Files
      run: |
        echo "📁 复制 ROM 文件到工作目录"
        cd MrChromebox
        mkdir -p ../roms
        cp roms/*.rom ../roms/ || echo "未找到 ROM 文件"
        ls -la ../roms/

    - name: 创建 Release / Create Release
      if: ${{ (github.event_name == 'workflow_dispatch' && inputs.release) || (github.event_name != 'workflow_dispatch') }}
      uses: softprops/action-gh-release@v1
      with:
        tag_name: kaisa-official-edk2-${{ github.run_number }}
        name: "${{ inputs.release_name || 'Coreboot Kaisa - 方案8 (Official EDK2 Network)' }} #${{ github.run_number }}"
        body: |
          # 🎯 方案8：原版 EDK2 网络支持测试
          
          ## 🔧 原版 EDK2 配置
          - **使用官方 EDK2 仓库**：tianocore/edk2
          - **网络功能启用**：NETWORK_ENABLE=TRUE
          - **IPv6 禁用**：NETWORK_IP6_ENABLE=FALSE（节省空间）
          - **EFI Shell 包含**：用于网络功能测试
          ${{ env.EDK2_CONFIG_LIST }}
          
          ## 🔍 测试目标
          - 验证原版 EDK2 对 PCIe 网卡的支持
          - 检查 RTL8168 网卡是否被识别
          - 测试网络启动功能是否可用
          - 分析网络驱动的包含情况
          
          ## ⚠️ 重要说明
          - 这是实验性测试，验证原版 EDK2 的网络支持能力
          - 如果网络功能不完整，建议使用方案7的混合方案
          - 需要实际测试来验证 RTL8168 网卡支持
          
          ## 🚀 测试方法
          1. **刷入固件**：将 ROM 刷入主板
          2. **检查启动菜单**：查看是否有网络启动选项
          3. **进入 EFI Shell**：检查网卡是否被识别
          4. **测试网络功能**：尝试网络启动
          
          ${{ env.INTEL_CONFIG_LIST != '' && format('同时追加 Intel 芯片组稳定性相关配置（适配 Kaisa 主板）：\n{0}', env.INTEL_CONFIG_LIST) || '' }}
            
          **构建时间**: ${{ github.event.repository.updated_at }}
        files: |
          roms/*.rom
